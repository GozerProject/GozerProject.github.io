<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Gozer Project</title>
	<meta name="description" content=""/>
	<meta name="keywords" content="modeling, MDE, MDA, framework, java, kotlin, scala, javascript, kevoree, KMF, EMF, ecore, xmi, json"/>
	<meta name="author" content="Fouquet Francois"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<link rel="shortcut icon" type="image/icon" href="favicon.ico"/>
	<!-- CSS -->
	<link rel="stylesheet" href="css/custom.min.css"/>
	<link rel="stylesheet" href="css/tuktuk.min.css"/>
	<link rel="stylesheet" href="css/tuktuk.theme.min.css"/>
	<link rel="stylesheet" href="css/tuktuk.icons.css"/>
	
	<link rel="stylesheet" href="highlight/styles/tomorrow.css"/>
	<script src="highlight/zepto.min.js"></script>
	<script src="highlight/highlight.pack.js"></script>	         
</head>
 
<body>
	<header class="bck light padding">
		<div class="row">
			<div class="column_6">
				<a href=".">
					<h2 class="color theme text bold">Gozer Project</h2>
				</a>
			</div>
			<nav class="column_6 text right bold">
				<a href="#home">Home</a>
				<a href="#about">About</a>
				<a href="#features">Features</a>
				<a href="#contribute">Contribute</a>
			</nav>
		</div>
	</header>
	
	<section class="bck dark padding" id="home">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<!--<img src="img/kevoree-rond-blanc.png" alt="Logo" class="margin-bottom"/>-->
				<h1 class="color theme text bold center">Make continuous deployment simple !</h1>
				<h3 class="text thin center">Dev tools use project descriptors like <strong>Maven</strong>, <strong>Gradle</strong>, <strong>SBT</strong>...<br /> 
					It allows better organization and modularity. <br /><strong>Great !</strong> but why do we need to build complex <strong>packaging</strong> for deployment ?<br />
					<strong>Gozer</strong> fill the gap between your dev and deploy phase by leveraging project descriptors to build continuous deployment ! So simple...</h3>
			</div>
		</div>
		<div class="row text center">
				<a id="openPlaygroundBT" href="https://github.com/GozerProject/gozer/wiki" target="_blank" class="button large"><span class="icon github disabled"></span>Documentation</a>
		</div>
		<br />
		<div class="row text left padding-top">
			<div class="column_3 offset_3">
				<h4 class="color text right bold">current version</h4>
			</div>
			<div class="column_2">
				<h4 class="color theme text bold center">ALPHA</h4>
			</div>
		</div>
	</section>
	
	<section class="bck theme padding" id="about">
		<div class="row text center book">
			<div class="column_10 offset_1">
				<h1 class="text bold color light">About Gozer project</h1>
				<h3>Gozer is a <strong>continous deployment engine</strong>. Imagine a simple gentleman which take care of pull your git repository and compile and take care to update your code directly in test or production server ! So relax push your code and refresh your browser...</h3>
			</div>
		</div>
	</section>

	<!--
	<section class="bck light padding" id="features">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="color theme text bold center">Features</h1>
			</div>
		</div>
		<div class="row text center">
				<h3 class="text bold">Let's take a concrete example</h3> 
				Concrete things are better to understand abstract modeling tools.
				<span class="icon comment" style="font-size: 20pt;"></span>
				<h3 class="text bold">When you think about Cloud <span class="icon cloud" style="font-size: 20pt;"></span> systems...</h3>
				<p>You think of hosting nodes <span class="icon home" style="font-size: 20pt;"></span>
					and hosted software <span class="icon cog" style="font-size: 20pt;"></span>.</p>
		</div>
	</section>
	
	<section class="bck white padding" id="features2">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Everything begins with a metamodel</h1>
			</div>
		</div>
		<div class="row text center">
			<div class="column_4 offset_2">
				<img src="img/cloudmetamodel.png" style="height:250px;"></img>
			</div>
			<div class="column_4 margin-bottom">
				<h3>A cloud is composed by</h3>
				<br />
				<h5>A collection of <span class="text bold">nodes</span> identified by an ID.</h5>
				<br />
				<h5>Each <span class="text bold">Node</span> contains several <span class="text bold">software</span> identified by their names.</h5>
				<br />
				<h5>Use any eclipse graphical or textual editor to produce an ecore metamodel.</h5>			
			</div>
		</div>
		<div class="row text center">
				<a href="playground/ecore.html" target="_blank" class="button secondary large"><span class="icon download disabled"></span>See the XMI</a>
		</div>
	</section>
	
	<section class="bck theme padding" id="features3">
		
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Then KMF generates POJO *like* API</h1>
			</div>
		</div>
		
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code style="border-radius:8px;">
//Creation of a Cloud instance
Cloud cloud = factory.createCloud();
//Creation of a Node
Node myAmazonEC2node = factory.createNode();
myAmazonEC2node.setId("EC2_0");
//Adding the node to the cloud
cloud.addNodes(myAmazonEC2node);
//Creation of a Software
Softwzre myNginx = factory.createSoftware();
myNginx.setName("SRV0");
//Attaching the software to the node
myAmazonEC2node.addSoftwares(myNginx);					
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
//create a cloud
var cloud = factory.createCloud();
//create a node
var myAmazonEC2node = factory.createNode();
myAmazonEC2node.id = "EC2_0";
//add node to your cloud
cloud.addNodes(myAmazonEC2node);
//create a software
var myNginx = factory.createSoftware();
myNginx.name = "SRV0";
//attach the software to your new node
myAmazonEC2node.addSoftwares(myNginx);					
				</code></pre>				
			</div>
		</div>
	</section>
	
	<section class="bck white padding" id="features4">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Easily access model elements using IDs and Paths</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code>
//select your node by ID
Node ec2node = cloud.findNodesByID("EC2_0");
//or with XPath style
ec2node = cloud.findByPath("nodes[EC2_0]");
//then select a software
Software soft = ec2node.findSoftwaresByName("SRV0");
//or by path
soft=cloud.findByPath("nodes[EC2_0]/softwares[SRV0]");
//print the path of any element
System.out.println(soft.path(););
//print on console : nodes[EC2_0]/softwares[SRV0]
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code>
//select your node by ID
var ec2node = cloud.findNodesByID("EC2_0");
//or with XPath style
ec2node = cloud.findByPath("nodes[EC2_0]");
//then select a software
var soft = ec2node.findSoftwaresByName("SRV0");
//or by path
soft=cloud.findByPath("nodes[EC2_0]/softwares[SRV0]");
//print the path of any element
console.log(soft.path(););
//print on console : nodes[EC2_0]/softwares[SRV0]
				</code></pre>				
			</div>
		</div>
		
		<div class="row text center book margin-bottom margin-top">
			<p>Model elements selection using paths is way faster than iterating on collections. <br/>
                Similarly to database IDs or NoSQL indexes, KMF uses hashtables to speed up the lookup of elements.</p>
		</div>
		
	</section>
	
	<section class="bck light padding" id="features5">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Load, Save and Clone your models in XMI or JSON</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code style="border-radius:8px;">
ModelCloner     cloner = new DefaultModelCloner();
ModelSerializer jsonSaver = new JSONModelSerializer();
ModelLoader     jsonLoader = new JSONModelLoader();
ModelSerializer xmiSaver = new XMIModelSerializer();
ModelLoader     xmiLoader = new XMINModelLoader();

//Save in standard XMI Format (work Eclipse)
System.out.println(xmiSaver.serialize(myCloud));
//Save in human readable JSON
System.out.println(jsonSaver.serialize(myCloud));

//Load from JSON and take first package (only one here)
Cloud cloud = jsonLoader
	.loadModelFromString(txtPayLoad).get(0);
//Load from XMI
Cloud cloud = xmiLoader
	.loadModelFromString(txtPayLoad).get(0);

//Clone the entire model
Cloud clonedModel = cloner.clone(cloud);
//Clone to a readonly structure
clonedModel = cloner.clone(cloud,true);
//Only clone a part of model, share the first node
cloud.getNodes().get(0).setRecursiveReadOnly();
Cloud clonedModel = cloner.cloneMutableOnly(cloud);
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
var cloner = new DefaultModelCloner();
var jsonSaver = new JSONModelSerializer();
var jsonLoader = new JSONModelLoader();
var xmiSaver = new XMIModelSerializer();
var xmiLoader = new XMINModelLoader();

//Save in human readable JSON
console.log(jsonSaver.serialize(myCloud));

//Load from JSON and take first package
var cloud = jsonLoader
	.loadModelFromString(txtPayLoad).get(0);

//Clone the entire model
var clonedModel = cloner.clone(cloud);
//Clone to a readonly structure
var clonedModel = cloner.clone(cloud,true);
//Only clone a part of model, share the first node
cloud.getNodes().get(0).setRecursiveReadOnly();
var clonedModel = cloner.cloneMutableOnly(cloud);

//save into XMI format
var savedModel = xmiSaver.serialize(cloud);
//reload from XMI stream
var reloadCloud = xmiLoader
	.loadModelFromString(savedModel);

				</code></pre>				
			</div>
		</div>
		<div class="row text center book margin-bottom margin-top">
			<p>We support the standard <strong>XMI interchange format</strong> for compatibility with other modeling framework tool like EMF.<br/>
               In addition KMF offers to serialize your models in <strong>JSON format</strong> for more portability, especially designed for web usage.<br/>
               KMF allows to set part of the model as Read-Only. With this feature, the clone operator is able to efficiently clone mutable elements only.<br/>
               This ability drastically speeds up the cloning and enables processes of clones in parallel.</p>
		</div>
	</section>
	
	<section class="bck theme padding" id="features6">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Use Events to stay informed</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code style="border-radius:8px;">
//Create a listener
class ModelSyncListener implements ModelTreeListener {
    @Override
    public void elementChanged(ModelEvent event){
	   switch(event.getType()){
	     case ActionType.ADD:
	       System.out.println("Add "+event);
	       break;
	     case ActionType.SET:
	       System.out.println("Set "+event);
               break;
	   }
    }
}
//Add it as TreeListener
//Listens this element + all contained
cloud.addModelTreeListener(new ModelSyncListener());
//Std listener only listen local event
//cloud.addModelListener(new ModelSyncListener());
Node node = factory.createNode();
node.setID("EC1");
//Trigger event ADD 
cloud.addNodes(node);
//Trigger event SET
node.setId("EC2_1");
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
//Declare events listener
var listener = { elementChanged : function(event){
 switch(event.getType()){
  case ActionType.$ADD:
    console.log("Add event ! "+event);
	break;
  case ActionType.$SET:
    console.log("Set event ! "+event);
	break;
 }
}};
//Add as Tree (meaning global) listener
cloud.addModelTreeListener(listener);
//Std listener only listen local event
//cloud.addModelListener(listener);
var node = factory.createNode();
node.id = "EC1";
//Trigger event ADD 
cloud.addNodes(node);
//Trigger event SET
node.id = "EC2_1";
				</code></pre>				
			</div>
		</div>
		<div class="row text center book margin-bottom margin-top">
			<p>Events are triggered each time an attribute or a relation of a model element is edited.<br/>
               They make it easier to synchronize a presentation layer like a DOM fragment and the modeling layer.</p>
		</div>
	</section>
	
	<section class="bck white padding" id="features7">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Set operators to merge and compare</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code style="border-radius:8px;">
ModelCompare compare = new DefaultModelCompare();

//Produces the trace sequence to go from MO to M1
TraceSequence diffSeq = compare.diff(model0,model1);
//Produces the trace sequence of MO inter M1
TraceSequence interSeq = compare.inter(model0,model1);
//Produces the trace sequence of MO merged with M1
TraceSequence mergeSeq = compare.merge(model0,model1);
for(trace : diffSeq.getTraces()){
	//Prints the difference between M0 and M1
	System.out.println(trace);
}
//Merges M1 into M0
mergeSeq.applyOn(model0);
assert(model1.modelEquals(m0));
Cloud model3 = factory.createCloud();
interSeq.applyOn(model3);
//model3 is now the common part of M0 and M1
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
var compare = new DefaultModelCompare();

//Produce the trace sequence of MO -> M1
var diffSeq = compare.diff(model0,model1);
//Produce the trace sequence of MO inter M1
var interSeq = compare.inter(model0,model1);
//Produces the trace sequence of MO merged with M1
var mergeSeq = compare.merge(model0,model1);
for(i=0;i &lt; diffSeq.getTraces().$size;i++){
	//Print the comparison between M0 and M1
	console.log(diffSeq.getTraces()[i]);
}
//Merge M1 into M0
mergeSeq.applyOn(model0);
assert(model1.modelEquals(m0));
var model3 = factory.createCloud();
interSeq.applyOn(model3);
//model3 is now the common part of M0 and M1
				</code></pre>				
			</div>
		</div>
		<div class="row text center book margin-bottom margin-top">
			<p>Each set operator manipulates models as trace sequences. A Trace is defined as an atomic operation modifying a model (add, set, remove).<br/>
                Trace sequences can be applied on models, making it possible to build any operators using these atomic steps.</p>
		</div>
	</section>
	
	<section class="bck light padding" id="features8">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Synchronize your models incrementally !</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code style="border-radius:8px;">
Cloud cloudM0 = factory.createNode();
Cloud cloudM1 = factory.createNode();

ModelCompare compare = new DefaultModelCompare();
Event2Trace conv = new Event2Trace(compare);
cloudM0.addModelTreeListener(new ModelTreeListener(){
 @Override
 public void elementChanged(ModelEvent event) {
  TraceSequence traceSeq = conv.convert(event);
  //send via network for remote synchronisation
  //traceSeq are serialiable
  traceSeq.applyOn(cloudM1);
 }
});
//Add a new node to cloudM0
Node newNode = factory.createNode();
newNode.setId("newNode")
cloudM0.addNodes(newNode);
//Now CloudM1 has also create one node
assert(cloudM1.findNodesById("newNode") != null);
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
var cloudM0 = factory.createNode();
var cloudM1 = factory.createNode();

var compare = new DefaultModelCompare();
var conv = new Event2Trace(compare);
var listener = { elementChanged : function(event){
    var traces = apply.convert(event);
	//send trace to network or browser events
	//for remote synchronization
    traces.applyOn(cloudM1);
}};

//Add a new node to cloudM0
var newNode = factory.createNode();
newNode.setId("newNode")
cloudM0.addNodes(newNode);

//Now CloudM1 has also create one node
assert(cloudM1.findNodesById("newNode") != null);
				</code></pre>				
			</div>
		</div>
		<div class="row text center book margin-bottom margin-top">
			<p>To synchronize several model instances simply capture events, convert them to trace, broadcast, and apply on each models.<br/>
                Coupled with a conflict resolution mechanism, this makes the foundation for collaborative distributed modeling.</p>
		</div>
	</section>
    
    
    	<section class="bck white padding" id="features9">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Dive efficiently into models</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Java</h1>
					<pre><code style="border-radius:8px;">
ModelVisitor visitor = new ModelVisitor(){
    public override fun visit(
      KMFContainer elem,
      String refNameInParent,
	  KMFContainer parent) {
	    System.out.println(elem.path())
    }
}
//recursive navigation into contained elements
cloud.visit(true,true,false);
//recursive navigation into not contained references
cloud.visit(true,false,true);
//Non recursive navigation into cloud references
cloud.visit(false,true,true);

ModelAttributesVisitor visitorAtts 
	= new ModelAttributesVisitor(){
    public override fun visit(
      Object attValue,
      String name,
	  KMFContainer parent) {
	    System.out.println("Visit "+name)
    }
}
//Visit all attributes of Cloud
cloud.visit(visitorAtts);

				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
var visitor = new ModelVisitor();
visitor.visit = function(modelElem){
	console.log(modelElem.metaClassName());
}
//recursive navigation into contained elements
cloud.visit(true,true,false);
//recursive navigation into not contained references
cloud.visit(true,false,true);
//Non recursive navigation into cloud references
cloud.visit(false,true,true);

var visitorAtts = new ModelAttributesVisitor();
visitorAtts.visit = function(attValue,name,parent) {
	console.log(name);
}
//Visit all attributes of Cloud
cloud.visit(visitorAtts);
				</code></pre>				
			</div>
		</div>
		<div class="row text center book margin-bottom margin-top">
			<p>The Visitor API replaces the natural iterative navigation through model elements. 
				You can choos to visit recursively or not (first boolean parameters).
				Visit methods are generated to offer best performances.
				In addition users can stop the recursion at anytime by using the stopVisit() methods inside the visitor object to globally stop the process.
				Also, noChildrenVisit() skips children.</p>
		</div>
	</section>
    
	<section class="bck light padding" id="features10">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold">Inject behavior and build executable model</h1>
			</div>
		</div>
		<div class="row">
			<div class="column_6">
				<h1 class="color text theme bold center">Kotlin (JVM) and JS</h1>
					<pre><code style="border-radius:8px;">
//declare a new aspect on Node
aspect trait NodeAspect : Node {
	//private method
	//are not include in model
	private fun privateProcess(){};
	//method add to Node metaClass
	fun newService(){}
}
//Add a new concept named ExNode
//The new concept will inherit Node
metaClass("ExNode") ExNodeA : Node {
	//public method
	fun ExRun(){
	}
}
//create an instance of the concept
var newNode = factory.createExNode();
				</code></pre>				
			</div>
			<div class="column_6">
				<h1 class="color text theme bold center">JS</h1>
					<pre><code style="border-radius:8px;">
//JS version can use static aspects
//same as the JVM version.
//In addition model elements
//are generated extensible dynamically
//by leveraging prototypes

//add a method to the Node concept
factory.createNode().prototype.prettyPrint =
 function prettyPrint(){
   console.log(this.metaClassName());
}
//create a standard node object
var node = factory.createNode();
//call aspect method
node.prettyPrint();
				</code></pre>				
			</div>
		</div>
		<div class="row text center book margin-bottom margin-top">
			<p>Aspects replace the derived method of ecore. Allowing to write statically verified code instead of ugly putting code in </p>
		</div>
	</section>
		-->
	
	<section class="bck light padding">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold color dark">More are coming stay tuned...</h1>
			</div>
		</div>
		<div class="row text center book">
			<div class="column_4">
				<span class="icon dashboard" style="font-size: 100pt;"></span>
				<h3 class="text bold">Efficiency</h3>
				<p>Gozer takes efficiency seriously.<br/>With a <span class="text bold">minimal</span> but <span class="text bold">powerful</span> approach, you can expect the best performance at runtime for your deployments.</p>
			</div>
			<div class="column_4">
				<span class="icon comments" style="font-size: 100pt;"></span>
				<h3 class="text bold">Easy of Use</h3>
				<p>Unlike other deployment framework, Gozer tends to be <span class="text bold">simple</span> and <span class="text bold">uninstrusive</span>. Simply use a plain old main or war to deploy cloud apps.</p>
			</div>
			<div class="column_4">
				<span class="icon fullscreen" style="font-size: 100pt;"></span>
				<h3 class="text bold">Distributed</h3>
				<p><strong>Distributed deployment</strong> is enabled by Gozer thanks by Git mecanisms.<br/>
                    It is possible to synchronize severals deployment agents.</p>
			</div>
		</div>
	</section>
	
	<section class="bck color padding"  id="contribute">
		<div class="row text center book margin-bottom">
			<div class="column_10 offset_1">
				<h1 class="text bold color theme">Contribute</h1>
				<h3>Want to help? We're on <span class="text normal color white">GitHub</span>.
 Feel free to give us any feedback.</h3>
			</div>
		</div>
		<div class="row">
			<div class="column_4 offset_4 text center">
				<a href="https://github.com/GozerProject" target="_blank" class="button large secondary"><span class="icon github"></span>Source on GitHub</a>
			</div>
		</div>
	</section>
	
	<section class="bck dark padding">
		<div class="row margin-top margin-bottom">
			<div class="column_3">
				<p class="text bold big">Free Software</p>
					We're professional developpers
					<span class="text normal">Sébastien Brousse</span><br />(Brittany, France)<br />
					<span class="text normal">François Fouquet</span><br />(SnT Research Center, Luxembourg)<br />
			</div>
			<div class="column_4 offset_1">
				<p class="text bold big">Join the team</p>
					Help to build Gozer on <a href="https://github.com/GozerProject/gozer" class="text bold underline color theme">GitHub</a>.
			</div>
			<div class="column_3 offset_1">
				<p class="text bold big">Need some help?</p>
					Ask us on <span class="text normal"><a href="https://github.com/GozerProject/gozer/issues" class="text bold underline color theme">GitHub</a></span>!
			</div>
		</div>
	</section>
	<!--
	<footer class="bck light padding">
		<div class="row margin-top margin-bottom" style="text-align:center;">
			<a href="http://kevoree.org">KMF is a child project of Kevoree</a>
		</div>
	</footer>
		-->
    <script>
    	hljs.initHighlightingOnLoad();
    </script>
</body>
</html>
